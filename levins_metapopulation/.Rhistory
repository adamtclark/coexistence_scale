#!/usr/bin/env Rscript
#error
rm(list=ls())
setwd("~/Dropbox/ActiveWork/Projects/019_Dave habitat loss/src/")
####################
# Functions
####################
makegrid<-function(xlng=50, ylng=50) {
xpos<-rep(1:xlng, ylng)
ypos<-rep(1:ylng, each=xlng)
posmat<-matrix(nrow=xlng, ncol=ylng, data=1:length(xpos))
return(list(xpos=xpos, ypos=ypos, lng=c(xlng, ylng), posmat=posmat))
}
populate<-function(gridout, nlst=0.1, clst=c(3,20), mlst=c(0.1, 0.1), radlst=3) {
if(sum(nlst)<1) {
nlst<-rep(round(prod(gridout$lng)*nlst), length(clst))
while(sum(nlst)/prod(gridout$lng)>1) {
nlst<-nlst/(prod(gridout$lng)*1.2)
nlst<-round(nlst)
}
}
spid<-factor(rep(1:length(nlst), nlst)) #species identities
deathdate<-NULL #scheduled date of death
#radlst #dispersal distance for each species
#species locations
pos_sp<-sample(1:length(gridout$xpos), sum(nlst))
patch_occupied<-numeric(length(gridout$xpos))
patch_occupied[pos_sp]<-1
return(list(spid=spid, nlst=nlst, clst=clst, mlst=mlst, radlst=radlst, pos_sp=pos_sp, patch_occupied=patch_occupied))
}
#tmax=20; nsteps=20; talktime=1
run_metapopulation<-function(tmax, nsteps, gridout, population, talktime=1) {
system("R CMD SHLIB run_metapopulation.c")
if(!is.loaded("run_metapopulation")) {
dyn.load("run_metapopulation.so")
} else {
dyn.unload("run_metapopulation.so")
dyn.load("run_metapopulation.so")
}
gridsize<-prod(gridout$lng); nsp<-length(population$clst); xylim<-gridout$lng; destroyed<-rep(0, gridsize)
c_sptraits<-population$clst; m_sptraits<-population$mlst; abundances<-population$nlst
output<-numeric((nsteps+1)*(nsp+1))
#make_colsites
if(is.infinite(population$radlst)) {
colsites<-cbind(gridout$xpos, gridout$ypos)-1
colsites<-colsites[!(colsites[,1]==0 & colsites[,2]==0),]
} else {
dists<-seq(-population$radlst, population$radlst)
colsites<-expand.grid(dists, dists)
colsites<-colsites[!(colsites[,1]==0 & colsites[2]==0),]
colsites<-colsites[sqrt(colsites[,1]^2+colsites[,2]^2)<=population$radlst,]
colsites<-unname(unlist(colsites))
}
ncolsites<-length(colsites)/2
#species info
speciesid<-rep(nsp, gridsize) #empty
speciesid[population$pos_sp]<-as.numeric(population$spid)-1
#make events
eventtimes_c<-numeric(gridsize)
eventtimes_m<-numeric(gridsize)
n<-1
for(i in 1:length(population$spid)) {
x<-runif(1)
eventtimes_c[population$pos_sp[i]]<-log(-x+1)/(-c(population$clst[population$spid[i]]))
x<-runif(1)
eventtimes_m[population$pos_sp[i]]<-log(-x+1)/(-c(population$mlst[population$spid[i]]))
}
eventtimes_c[!is.finite(eventtimes_c)]<-tmax+1
eventtimes_m[!is.finite(eventtimes_m)]<-tmax+1
#print(speciesid)
#print(round(eventtimes_c, 3))
#print(round(eventtimes_m, 3))
if(gridsize>1e6) {
print("error: must compile code with larger buffer size!")
} else {
cout<-.C("run_metapopulation",
ptmax= as.double(tmax), pgridsize=as.integer(gridsize), pnsp=as.integer(nsp), xylim=as.integer(xylim), destroyed=as.integer(destroyed), #grid
c_sptraits=as.double(c_sptraits), m_sptraits=as.double(m_sptraits), abundances=as.integer(abundances), colsites=as.integer(colsites), pncolsites=as.integer(ncolsites), #traits
eventtimes_c=as.double(eventtimes_c), eventtimes_m=as.double(eventtimes_m), #events
speciesid=as.integer(speciesid), #species
output=as.double(output), pnsteps=as.integer(nsteps),
ptalktime=as.integer(talktime))
out<-matrix(cout$output, nrow=nsteps+1)
nsp<-ncol(out)-1
ngrid<-prod(gridout$lng)
matplot(out[,1], out[,-1]/ngrid, type="l", xlab="time", ylab="p",
lty=1, col=1:nsp, lwd=2)
ceq<-numeric(nsp)
for(i in 1:nsp) {
ceq[i]<-(1-population$mlst[i]/population$clst[i])-sum(ceq[0:(i-1)])
}
abline(h=ceq,
lty=2, col=1:nsp, lwd=2)
return(list(output=out, full=cout))
}
}
gridout<-makegrid(xlng = 100, ylng = 100)
population<-populate(gridout, nlst = rep(round(0.1*prod(gridout$lng)), 4), clst = c(0.15, 1, 10, 100), mlst = rep(0.1, 4), radlst = Inf)
out<-run_metapopulation(tmax=200, nsteps = 1000, gridout, population, talktime = 0)
out$output
#load
e014dat<-read.csv("~/Dropbox/Projects/old/019_Dave habitat loss/src/data/e014_abund_data.csv")
#Get c values
m<-0.1
clst<-numeric(nrow(e014dat))
plst<-numeric(nrow(e014dat))
for(i in 1:nrow(e014dat)) {
preq<-e014dat$cumSum[i]
clst[i]<-m/(1-preq)
plst[i]<-preq-sum(plst)
}
gridout<-makegrid(xlng = 1000, ylng = 1000)
n<-200
population<-populate(gridout, nlst = round(plst[1:n]*prod(gridout$lng)), clst = clst[1:n], mlst = rep(m, n), radlst = 100)
x1<-Sys.time()
out<-run_metapopulation(tmax=100, nsteps = 100, gridout, population, talktime = 1)
x2<-Sys.time()
x2-x1
gridout<-makegrid(xlng = 100, ylng = 100)
population<-populate(gridout, nlst = rep(round(0.1*prod(gridout$lng)), 4), clst = c(0.15, 1, 10, 100), mlst = rep(0.1, 4), radlst = Inf)
out<-run_metapopulation(tmax=200, nsteps = 1000, gridout, population, talktime = 0)
#!/usr/bin/env Rscript
#error
rm(list=ls())
setwd("~/Dropbox/ActiveWork/Projects/019_Dave habitat loss/src/")
####################
# Functions
####################
makegrid<-function(xlng=50, ylng=50) {
xpos<-rep(1:xlng, ylng)
ypos<-rep(1:ylng, each=xlng)
posmat<-matrix(nrow=xlng, ncol=ylng, data=1:length(xpos))
return(list(xpos=xpos, ypos=ypos, lng=c(xlng, ylng), posmat=posmat))
}
populate<-function(gridout, nlst=0.1, clst=c(3,20), mlst=c(0.1, 0.1), radlst=3) {
if(sum(nlst)<1) {
nlst<-rep(round(prod(gridout$lng)*nlst), length(clst))
while(sum(nlst)/prod(gridout$lng)>1) {
nlst<-nlst/(prod(gridout$lng)*1.2)
nlst<-round(nlst)
}
}
spid<-factor(rep(1:length(nlst), nlst)) #species identities
deathdate<-NULL #scheduled date of death
#radlst #dispersal distance for each species
#species locations
pos_sp<-sample(1:length(gridout$xpos), sum(nlst))
patch_occupied<-numeric(length(gridout$xpos))
patch_occupied[pos_sp]<-1
return(list(spid=spid, nlst=nlst, clst=clst, mlst=mlst, radlst=radlst, pos_sp=pos_sp, patch_occupied=patch_occupied))
}
#tmax=20; nsteps=20; talktime=1
run_metapopulation<-function(tmax, nsteps, gridout, population, talktime=1) {
system("R CMD SHLIB run_metapopulation.c")
if(!is.loaded("run_metapopulation")) {
dyn.load("run_metapopulation.so")
} else {
dyn.unload("run_metapopulation.so")
dyn.load("run_metapopulation.so")
}
gridsize<-prod(gridout$lng); nsp<-length(population$clst); xylim<-gridout$lng; destroyed<-rep(0, gridsize)
c_sptraits<-population$clst; m_sptraits<-population$mlst; abundances<-population$nlst
output<-numeric((nsteps+1)*(nsp+1))
#make_colsites
if(is.infinite(population$radlst)) {
colsites<-cbind(gridout$xpos, gridout$ypos)-1
colsites<-colsites[!(colsites[,1]==0 & colsites[,2]==0),]
} else {
dists<-seq(-population$radlst, population$radlst)
colsites<-expand.grid(dists, dists)
colsites<-colsites[!(colsites[,1]==0 & colsites[2]==0),]
colsites<-colsites[sqrt(colsites[,1]^2+colsites[,2]^2)<=population$radlst,]
colsites<-unname(unlist(colsites))
}
ncolsites<-length(colsites)/2
#species info
speciesid<-rep(nsp, gridsize) #empty
speciesid[population$pos_sp]<-as.numeric(population$spid)-1
#make events
eventtimes_c<-numeric(gridsize)
eventtimes_m<-numeric(gridsize)
n<-1
for(i in 1:length(population$spid)) {
x<-runif(1)
eventtimes_c[population$pos_sp[i]]<-log(-x+1)/(-c(population$clst[population$spid[i]]))
x<-runif(1)
eventtimes_m[population$pos_sp[i]]<-log(-x+1)/(-c(population$mlst[population$spid[i]]))
}
eventtimes_c[!is.finite(eventtimes_c)]<-tmax+1
eventtimes_m[!is.finite(eventtimes_m)]<-tmax+1
#print(speciesid)
#print(round(eventtimes_c, 3))
#print(round(eventtimes_m, 3))
if(gridsize>1e6) {
print("error: must compile code with larger buffer size!")
} else {
cout<-.C("run_metapopulation",
ptmax= as.double(tmax), pgridsize=as.integer(gridsize), pnsp=as.integer(nsp), xylim=as.integer(xylim), destroyed=as.integer(destroyed), #grid
c_sptraits=as.double(c_sptraits), m_sptraits=as.double(m_sptraits), abundances=as.integer(abundances), colsites=as.integer(colsites), pncolsites=as.integer(ncolsites), #traits
eventtimes_c=as.double(eventtimes_c), eventtimes_m=as.double(eventtimes_m), #events
speciesid=as.integer(speciesid), #species
output=as.double(output), pnsteps=as.integer(nsteps),
ptalktime=as.integer(talktime))
out<-matrix(cout$output, nrow=nsteps+1)
nsp<-ncol(out)-1
ngrid<-prod(gridout$lng)
ceq<-numeric(nsp)
for(i in 1:nsp) {
ceq[i]<-(1-population$mlst[i]/population$clst[i])-sum(ceq[0:(i-1)])
}
return(list(output=out, full=cout, ceq=ceq))
}
}
plot_metapop<-function(output) {
out<-output$out
ceq<-output$ceq
matplot(out[,1], out[,-1]/ngrid, type="l", xlab="time", ylab="p",
lty=1, col=1:nsp, lwd=2)
abline(h=ceq,
lty=2, col=1:nsp, lwd=2)
}
gridout<-makegrid(xlng = 100, ylng = 100)
population<-populate(gridout, nlst = rep(round(0.1*prod(gridout$lng)), 4), clst = c(0.15, 1, 10, 100), mlst = rep(0.1, 4), radlst = Inf)
out<-run_metapopulation(tmax=200, nsteps = 1000, gridout, population, talktime = 0)
plot_metapop(out)
#!/usr/bin/env Rscript
#error
rm(list=ls())
setwd("~/Dropbox/ActiveWork/Projects/019_Dave habitat loss/src/")
####################
# Functions
####################
makegrid<-function(xlng=50, ylng=50) {
xpos<-rep(1:xlng, ylng)
ypos<-rep(1:ylng, each=xlng)
posmat<-matrix(nrow=xlng, ncol=ylng, data=1:length(xpos))
return(list(xpos=xpos, ypos=ypos, lng=c(xlng, ylng), posmat=posmat))
}
populate<-function(gridout, nlst=0.1, clst=c(3,20), mlst=c(0.1, 0.1), radlst=3) {
if(sum(nlst)<1) {
nlst<-rep(round(prod(gridout$lng)*nlst), length(clst))
while(sum(nlst)/prod(gridout$lng)>1) {
nlst<-nlst/(prod(gridout$lng)*1.2)
nlst<-round(nlst)
}
}
spid<-factor(rep(1:length(nlst), nlst)) #species identities
deathdate<-NULL #scheduled date of death
#radlst #dispersal distance for each species
#species locations
pos_sp<-sample(1:length(gridout$xpos), sum(nlst))
patch_occupied<-numeric(length(gridout$xpos))
patch_occupied[pos_sp]<-1
return(list(spid=spid, nlst=nlst, clst=clst, mlst=mlst, radlst=radlst, pos_sp=pos_sp, patch_occupied=patch_occupied))
}
#tmax=20; nsteps=20; talktime=1
run_metapopulation<-function(tmax, nsteps, gridout, population, talktime=1) {
system("R CMD SHLIB run_metapopulation.c")
if(!is.loaded("run_metapopulation")) {
dyn.load("run_metapopulation.so")
} else {
dyn.unload("run_metapopulation.so")
dyn.load("run_metapopulation.so")
}
gridsize<-prod(gridout$lng); nsp<-length(population$clst); xylim<-gridout$lng; destroyed<-rep(0, gridsize)
c_sptraits<-population$clst; m_sptraits<-population$mlst; abundances<-population$nlst
output<-numeric((nsteps+1)*(nsp+1))
#make_colsites
if(is.infinite(population$radlst)) {
colsites<-cbind(gridout$xpos, gridout$ypos)-1
colsites<-colsites[!(colsites[,1]==0 & colsites[,2]==0),]
} else {
dists<-seq(-population$radlst, population$radlst)
colsites<-expand.grid(dists, dists)
colsites<-colsites[!(colsites[,1]==0 & colsites[2]==0),]
colsites<-colsites[sqrt(colsites[,1]^2+colsites[,2]^2)<=population$radlst,]
colsites<-unname(unlist(colsites))
}
ncolsites<-length(colsites)/2
#species info
speciesid<-rep(nsp, gridsize) #empty
speciesid[population$pos_sp]<-as.numeric(population$spid)-1
#make events
eventtimes_c<-numeric(gridsize)
eventtimes_m<-numeric(gridsize)
n<-1
for(i in 1:length(population$spid)) {
x<-runif(1)
eventtimes_c[population$pos_sp[i]]<-log(-x+1)/(-c(population$clst[population$spid[i]]))
x<-runif(1)
eventtimes_m[population$pos_sp[i]]<-log(-x+1)/(-c(population$mlst[population$spid[i]]))
}
eventtimes_c[!is.finite(eventtimes_c)]<-tmax+1
eventtimes_m[!is.finite(eventtimes_m)]<-tmax+1
#print(speciesid)
#print(round(eventtimes_c, 3))
#print(round(eventtimes_m, 3))
if(gridsize>1e6) {
print("error: must compile code with larger buffer size!")
} else {
cout<-.C("run_metapopulation",
ptmax= as.double(tmax), pgridsize=as.integer(gridsize), pnsp=as.integer(nsp), xylim=as.integer(xylim), destroyed=as.integer(destroyed), #grid
c_sptraits=as.double(c_sptraits), m_sptraits=as.double(m_sptraits), abundances=as.integer(abundances), colsites=as.integer(colsites), pncolsites=as.integer(ncolsites), #traits
eventtimes_c=as.double(eventtimes_c), eventtimes_m=as.double(eventtimes_m), #events
speciesid=as.integer(speciesid), #species
output=as.double(output), pnsteps=as.integer(nsteps),
ptalktime=as.integer(talktime))
out<-matrix(cout$output, nrow=nsteps+1)
nsp<-ncol(out)-1
ngrid<-prod(gridout$lng)
ceq<-numeric(nsp)
for(i in 1:nsp) {
ceq[i]<-(1-population$mlst[i]/population$clst[i])-sum(ceq[0:(i-1)])
}
plotdata<-list(ceq=ceq, ngrid=ngrid)
return(list(output=out, full=cout, plotdata=plotdata))
}
}
plot_metapop<-function(output) {
out<-output$out
ceq<-output$plotdata$ceq
ngrid<-output$plotdata$ngrid
matplot(out[,1], out[,-1]/ngrid, type="l", xlab="time", ylab="p",
lty=1, col=1:nsp, lwd=2)
abline(h=ceq,
lty=2, col=1:nsp, lwd=2)
}
gridout<-makegrid(xlng = 100, ylng = 100)
population<-populate(gridout, nlst = rep(round(0.1*prod(gridout$lng)), 4), clst = c(0.15, 1, 10, 100), mlst = rep(0.1, 4), radlst = Inf)
out<-run_metapopulation(tmax=200, nsteps = 1000, gridout, population, talktime = 0)
plot_metapop(out)
plot_metapop<-function(output) {
out<-output$out
ceq<-output$plotdata$ceq
ngrid<-output$plotdata$ngrid
matplot(out[,1], out[,-1]/ngrid, type="l", xlab="time", ylab="p",
lty=1, col=1:ncol(out), lwd=2)
abline(h=ceq,
lty=2, col=1:ncol(out), lwd=2)
}
gridout<-makegrid(xlng = 100, ylng = 100)
population<-populate(gridout, nlst = rep(round(0.1*prod(gridout$lng)), 4), clst = c(0.15, 1, 10, 100), mlst = rep(0.1, 4), radlst = Inf)
out<-run_metapopulation(tmax=200, nsteps = 1000, gridout, population, talktime = 0)
plot_metapop(out)
plot_metapop(out)
error
rm(list=ls())
setwd("~/Dropbox/Projects/032_Coexistence_table/src/levins_metapopulation/")
gridout<-makegrid(xlng = 100, ylng = 100)
rep(round(0.1*prod(gridout$lng))
)
gridout<-makegrid(xlng = 100, ylng = 100)
population<-populate(gridout, nlst = rep(round(0.1*prod(gridout$lng)), 4), clst = c(0.15, 1, 10, 200), mlst = rep(0.1, 4), radlst = Inf)
out<-run_metapopulation(tmax=200, nsteps = 1000, gridout, population, talktime = 0)
error
rm(list=ls())
setwd("~/Dropbox/Projects/032_Coexistence_table/src/levins_metapopulation/")
#load functions
source("run_metapopulation_wrapper.R")
error
rm(list=ls())
setwd("~/Dropbox/Projects/032_Coexistence_table/src/levins_metapopulation/")
#load functions
source("run_metapopulation_wrapper.R")
gridout<-makegrid(xlng = 100, ylng = 100)
population<-populate(gridout, nlst = rep(round(0.1*prod(gridout$lng)), 4), clst = c(0.15, 1, 10, 200), mlst = rep(0.1, 4), radlst = Inf)
out<-run_metapopulation(tmax=200, nsteps = 1000, gridout, population, talktime = 0)
out$full$colsites
out$full$speciesid
length(out$full$speciesid)
out$full$xylim
gridout$xpos
plot(gridout$xpos, gridout$ypos, col=out$full$speciesid, pch=16)
population
population$spid
out$full$speciesid
str(population)
population$spid
str(population)
out$full$speciesid
levels(out$full$speciesid)
sort(unique(out$full$speciesid))
levels(population$spid)
